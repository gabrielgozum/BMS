/**
 * @brief CAN Interface
 *
 * This file includes functions to initialize the CAN peripheral, send and
 * receive CAN messages. Receiving functions will parse the CAN data and place
 * into the appropriate place.
 *
 */

#include <stdbool.h>
#include <stdint.h>
#include "driverlib/can.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "inc/hw_can.h"
#include "inc/hw_gpio.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_nvic.h"
#include "Lib_can.h"
#include "balancing.h"
#include "bms.h"
#include "can.h"
#include "charger.h"
#include "faults.h"
#include "fault_manager.h"
#include "eeprom.h"
#include "params.h"
#include "sdc_control.h"


// message timeouts
static uint16_t charger_timeout = 0;
static uint16_t aux_flags_timeout = 0;


// keep number of fault msgs sent at once in check
static uint8_t num_fault_msgs_in_5ms = 0;

// found in fault_manager.c autogenerated file
extern uint8_t fault_matrix_bit_flags[8];


static void can_msg_obj_init(void)
{
    //-------------------------------------------------------------------------
    // Tx Message Objects
    //-------------------------------------------------------------------------

    // Pack Information
    can_create_message(CAN_VITALS_OBJ_ID, CAN_VITALS_MSG_ID, CAN_VITALS_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_PACK_STATS_OBJ_ID, CAN_PACK_STATS_MSG_ID, CAN_PACK_STATS_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_SOC_OBJ_ID, CAN_SOC_MSG_ID, CAN_SOC_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);

    // Cell Broadcasts
    can_create_message(CAN_CELL_BROADCAST_1_OBJ_ID, CAN_CELL_BROADCAST_1_MSG_ID, CAN_CELL_BROADCAST_1_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_CELL_BROADCAST_2_OBJ_ID, CAN_CELL_BROADCAST_2_MSG_ID, CAN_CELL_BROADCAST_2_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_CELL_BROADCAST_3_OBJ_ID, CAN_CELL_BROADCAST_3_MSG_ID, CAN_CELL_BROADCAST_3_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);

    // Cell Statistics
    can_create_message(CAN_STATS_CELL_VOLTAGE_OBJ_ID, CAN_STATS_CELL_VOLTAGE_MSG_ID, CAN_STATS_CELL_VOLTAGE_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_CELL_TEMPERATURE_OBJ_ID, CAN_STATS_CELL_TEMPERATURE_MSG_ID, CAN_STATS_CELL_TEMPERATURE_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_OCV_OBJ_ID, CAN_STATS_OCV_MSG_ID, CAN_STATS_OCV_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_CELL_DCH_RES_OBJ_ID, CAN_STATS_CELL_DCH_RES_MSG_ID, CAN_STATS_CELL_DCH_RES_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_CELL_CH_RES_OBJ_ID, CAN_STATS_CELL_CH_RES_MSG_ID, CAN_STATS_CELL_CH_RES_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_SOC_OBJ_ID, CAN_STATS_SOC_MSG_ID, CAN_STATS_SOC_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_STATS_CAPACITY_OBJ_ID, CAN_STATS_CAPACITY_MSG_ID, CAN_STATS_CAPACITY_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);

    // Charger Messages
    can_create_message(CAN_CHARGER_CMD_OBJ_ID, CAN_CHARGER_CMD_MSG_ID, CAN_CHARGER_CMD_LEN, MSG_OBJ_EXTENDED_ID, CAN_TX);

    // Debug
    can_create_message(CAN_BMS_VERSION_OBJ_ID, CAN_BMS_VERSION_MSG_ID, CAN_BMS_VERSION_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_CELL_BALANCING_OBJ_ID, CAN_CELL_BALANCING_MSG_ID, CAN_CELL_BALANCING_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_DEBUG_OBJ_ID, CAN_DEBUG_MSG_ID, CAN_DEBUG_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);

    // Fault Messages
    can_create_message(CAN_FAULTS_OBJ_ID, CAN_FAULTS_MSG_ID, CAN_FAULTS_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);
    can_create_message(CAN_FAULTS_MATRIX_OBJ_ID, CAN_FAULTS_MATRIX_MSG_ID, CAN_FAULTS_MATRIX_LEN, MSG_OBJ_NO_FLAGS, CAN_TX);

    //-------------------------------------------------------------------------
    // Rx Message Objects
    //-------------------------------------------------------------------------

    // Configuration
    can_create_message(CAN_CONFIG_OBJ_ID, CAN_CONFIG_MSG_ID, CAN_CONFIG_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);

    // Charger
    can_create_message(CAN_CHARGER_STATUS_OBJ_ID, CAN_CHARGER_STATUS_MSG_ID, CAN_CHARGER_STATUS_LEN, MSG_OBJ_EXTENDED_ID, CAN_RX);

    // Inverter fault
    can_create_message(CAN_IFR_FAULT_OBJ_ID, CAN_IFR_FAULT_MSG_ID, CAN_IFR_FAULT_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);
    can_create_message(CAN_IFL_FAULT_OBJ_ID, CAN_IFL_FAULT_MSG_ID, CAN_IFL_FAULT_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);
    can_create_message(CAN_IRL_FAULT_OBJ_ID, CAN_IRL_FAULT_MSG_ID, CAN_IRL_FAULT_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);
    can_create_message(CAN_IRR_FAULT_OBJ_ID, CAN_IRR_FAULT_MSG_ID, CAN_IRR_FAULT_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);

    // Bootloader ping
    can_create_message(CAN_BOOTLOADER_PING_OBJ_ID, CAN_BOOTLOADER_PING_MSG_ID, CAN_BOOTLOADER_PING_LEN, MSG_OBJ_EXTENDED_ID, CAN_RX);

    // AuxMCU Flags
    can_create_message(CAN_AUX_FLAGS_OBJ_ID, CAN_AUX_FLAGS_MSG_ID, CAN_AUX_FLAGS_LEN, MSG_OBJ_NO_FLAGS, CAN_RX);
}


void can_init(void)
{
    // enable alternate function
    GPIOPinTypeCAN(GPIO_PORTE_BASE, GPIO_PIN_4 | GPIO_PIN_5);

    // select alternate function
    GPIOPinConfigure(GPIO_PE5_CAN0TX);
    GPIOPinConfigure(GPIO_PE4_CAN0RX);

    // enable clocking and wait for it to be ready
    SysCtlPeripheralEnable(SYSCTL_PERIPH_CAN0);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_CAN0)) {};

    // reset the state of the CAN module and message objects
    CANInit(CAN0_BASE);

    // set CAN bit rate
    CANBitRateSet(CAN0_BASE, SysCtlClockGet(), 500000);

    // enable CAN for operation
    CANEnable(CAN0_BASE);

    // Initialize the CAN message objects
    can_msg_obj_init();
}


void can_discharge_configure(void)
{
    CANDisable(CAN0_BASE); // disable while reconfiguring
    CANBitRateSet(CAN0_BASE, SysCtlClockGet(), 500000); // set bit rate
    CANEnable(CAN0_BASE); // re-enable CAN peripheral
}


void can_send_vitals(void)
{
    uint8_t data[CAN_VITALS_LEN];

    uint8_t flags = 0;

    if(!fault_is_aPowerStageOpen()) // Invert flag, as can message is powerstage closed
    {
        flags |= 0x80;
    }

    if (fault_is_fVehicleIdle())
    {
        flags |= 0x40;
    }

    if (fault_is_cVoltageFailsafeMode())
    {
        flags |= 0x10;
    }

    if (fault_is_cCurrentFailsafeMode())
    {
        flags |= 0x08;
    }

    if (fault_is_fBalancingActive())
    {
        flags |= 0x04;
    }

    // BMS Flags
    data[0] = flags;

    // DCL
    uint16_t dcl = bms.discharge_current_limit;
    data[1] = (uint8_t)(dcl);
    data[2] = (uint8_t)(dcl >> 8);

    // CCL
    data[3] = (uint8_t)(bms.charge_current_limit);

    // Max CT
    data[4] = (uint8_t)bms.cell_temperature_stats.max;

    // Max CCV
    data[5] = (uint8_t)(bms.closed_cell_voltage_stats.max / 1000);

    // Min CCV
    data[6] = (uint8_t)(bms.closed_cell_voltage_stats.min / 1000);

    // Average CT
    data[7] = (uint8_t)(bms.cell_temperature_stats.average);

    can_send_message(CAN_VITALS_OBJ_ID, data);
}

void can_send_debug(void)
{
    uint8_t data[8];

    uint16_t i_pack_voltage = bms_get_i_pack_voltage() * 1000; // V to mV

    data[0] = (uint8_t)(i_pack_voltage);
    data[1] = (uint8_t)(i_pack_voltage >> 8);
    data[2] = 0;
    data[3] = 0;

    uint16_t i_pack_offset = bms_get_i_pack_offset();
    data[4] = (uint8_t)i_pack_offset;
    data[5] = (uint8_t)(i_pack_offset >> 8);
    data[6] = 0;
    data[7] = 0;

    can_send_message(CAN_DEBUG_OBJ_ID, data);
}

/**
 * Send the pack stats CAN message.
 */
void can_send_pack_stats(void)
{
   uint8_t data[CAN_PACK_STATS_LEN];

   // Pack I
   int16_t current = bms_get_i_pack() * CAN_PACK_I_GAIN;
   data[0] = (uint8_t)(current);
   data[1] = (uint8_t)(current >> 8);

   // Pack summed voltage - Already encoded
   uint16_t ccv_sum = bms.pack_ccv;
   data[2] = (uint8_t)(ccv_sum);
   data[3] = (uint8_t)(ccv_sum >> 8);

   // Pack open circuit voltage
   uint16_t ocv_sum = bms.pack_ocv;
   data[4] = (uint8_t)(ocv_sum);
   data[5] = (uint8_t)(ocv_sum >> 8);

   // Pack Discharge Resistance
   uint16_t cr_dch_sum = bms.pack_discharge_res;
   data[6] = (uint8_t)(cr_dch_sum);
   data[7] = (uint8_t)(cr_dch_sum >> 8);

   can_send_message(CAN_PACK_STATS_OBJ_ID, data);
}

/**
 * Send the BMS charger command CAN message.
 */
void can_send_charger_command(void)
{
    uint8_t data[CAN_CHARGER_CMD_LEN];

    data[0] = (charger.charge_enable & 0x03);
    data[0] |= ((charger.charge_complete << 2) & 0x0C);
    data[0] |= ((charger.charge_system_fault << 4) & 0x30);

    data[1] = (uint8_t)(charger.voltage_limit);

    data[2] = (uint8_t)((charger.voltage_limit >> 8) & 0x0f);
    data[2] |= (uint8_t)((charger.current_limit << 4) & 0xf0);

    data[3] = (uint8_t)(charger.current_limit >> 4);

    data[4] = 0;
    data[5] = 0;
    data[6] = 0;

    data[7] = 0xf; // checksum and charger not implemented (per Eaton)
                   // - send 0xf for counter and 0 for checksum

    can_send_message(CAN_CHARGER_CMD_OBJ_ID, data);
}


void can_send_fault(uint8_t *data)
{
    if (num_fault_msgs_in_5ms < 3)
    {
        can_send_message(CAN_FAULTS_OBJ_ID, data);
        num_fault_msgs_in_5ms++;
    }
}


void can_send_soc(void)
{
    uint8_t data[CAN_SOC_LEN];

    // SOC from model
    data[0] = bms_get_cell_soc_min() * 200.0;

    // SOE from model
    data[1] = 0;

    // SOC lookup - 0.1 mV / 10 0.1mV/mV / 1000mV/V
    float voltage = bms.closed_cell_voltage_stats.average / 10.0 / 1000.0;
    data[2] = lut_get_1d(&SOC_LUT, voltage);

    // SOE lookup
    data[3] = 0;

    // OCV lookup - V * 0.01V/V
    uint16_t ocv_lookup = lut_get_1d(&OCV_LUT, bms_get_cell_soc_min()) * 100 * TOTAL_CELLS;
    data[4] = (uint8_t)ocv_lookup;
    data[5] = (uint8_t)(ocv_lookup >> 8);

    // Pack Charge Resistance
    uint16_t pack_ch_resistance = bms.pack_charge_res;
    data[6] = (uint8_t)pack_ch_resistance;
    data[7] = (uint8_t)(pack_ch_resistance >> 8);

    can_send_message(CAN_SOC_OBJ_ID, data);
}


/**
 * @brief Calls the bootloader
 *
 * Passes control to the bootloader and initiates a remote software update.
 *
 * \return Never returns.
 */
static void call_bootloader(void)
{
    // Disable all processor interrupts.  Instead of disabling them
    // one at a time, a direct write to NVIC is done to disable all
    // peripheral interrupts.
    HWREG(NVIC_DIS0) = 0xffffffff;
    HWREG(NVIC_DIS1) = 0xffffffff;
    SysTickIntDisable();

    // Open the AIRS before rebooting
    sdc_control_open();

    // Take the CAN off the bus, but leave it configured.
    CANDisable(CAN0_BASE);

    // Return control to the boot loader.  This is a call to the SVC
    // handler in the boot loader.
    (*((void (*)(void))(*(uint32_t *)0x2c)))();
}

/**
 * Process the data for the charger status message.
 *
 * @param data received CAN data for the Charger Status message
 */
void can_parse_charger_status(uint8_t rx_data[])
{
    charger.input_voltage = rx_data[0];
    charger.output_voltage = rx_data[1];
    charger.input_current_limit_max = rx_data[2];
    charger.input_current = rx_data[3];
    charger.output_current = rx_data[4];
    charger.temperature = rx_data[5];
    charger.ignition_status = rx_data[6] & 0x03;
    charger.charger_state = (rx_data[6] >> 2) & 0x07;
    charger.fault_severity = (rx_data[6] >> 5) & 0x07;
}

/**
 * @brief Sends faults if messages from the ECU or charger are lost
 */
void can_check_timeouts(void)
{
    // charger fault
    if (charger_timeout > CHARGER_MSG_TIMEOUT)
    {
        fault_set_wChargerMIA();
    }
    else
    {
        fault_clear_wChargerMIA();
    }

    // aux flags timeout
    if (aux_flags_timeout > AUX_FLAGS_MSG_TIMEOUT)
    {
        fault_set_aAuxMIA();
    }
    else
    {
        fault_clear_aAuxMIA();
    }
}

/**
 * @brief Process the configuration message
 *
 * Updates set fields, and processes flag actions
 *
 * @param data The array of message data
 */
void can_parse_config(uint8_t rx_data[])
{
    // Flags
    if (rx_data[2] & 0x80) // EEPROM Clear Stats
    {
        //eeprom_clear(&bms.stored_stats);
    }

    if (rx_data[2] & 0x40) // EEPROM Clear Pack Capacity
    {
        //eeprom_soc_clear();
        //eeprom_capacity_clear();
    }

    bms.cell_balancing_commanded = rx_data[0] & 0x80;

    uint16_t voltage_limit = (rx_data[4] << 8) & (rx_data[3]);
    bms.balancing_vltg_limit = voltage_limit;
}

/**
 * @breif Read the AuxMCU Flags message
 *
 * @param data The array of message data
 */
void can_parse_aux_flags(uint8_t rx_data[])
{
    bms.airs_closed = rx_data[0] & 0x80; // AIRs_Closed is MSB of byte 0
}

/**
 * Process incoming CAN messages. Extract data and place into appropriate
 * struct.
 *
 */
void can_data_handler(void)
{
    uint32_t can_status;
    uint8_t rx_data[8];

    // increment timeout counters if not already faulted, and should be active
    if (fault_is_fChargerConnected() && !fault_is_wChargerMIA())
    {
        charger_timeout++;
    }

    if (fault_is_fChargerConnected()  && !fault_is_aAuxMIA()) // the auxmcu is only required for charging
                                                              // during charging the BMS watches the auxmcu AIR status
                                                              // if the AIRs are open the BMS will set the charge request to 0
    {
        aux_flags_timeout++;
    }

    // find the cause of the status interrupt
    can_status = CANIntStatus(CAN0_BASE, CAN_INT_STS_CAUSE);

    // if the cause is a controller status interrupt, get the status bits
    if (can_status == CAN_INT_INTID_STATUS)
    {
        can_status = CANStatusGet(CAN0_BASE, CAN_STS_CONTROL);
    }

    uint32_t pending_msg_obj_m = CANStatusGet(CAN0_BASE, CAN_STS_NEWDAT);

    // Charger Status
    if ((pending_msg_obj_m & CAN_CHARGER_STATUS_OBJ_ID_M)
        && fault_is_fChargerConnected()) // This message has been falsely received while driving.
                                         // This could be a permanent fix or there might be a
                                         // larger issue present.
    {
        can_read_message(CAN_CHARGER_STATUS_OBJ_ID, rx_data);
        can_parse_charger_status(rx_data);
        charger_timeout = 0;
    }

    // Config
    if (pending_msg_obj_m & CAN_CONFIG_OBJ_ID_M)
    {
        can_read_message(CAN_CONFIG_OBJ_ID, rx_data);

        can_parse_config(rx_data);

    }

    // Inverter fault
    if (pending_msg_obj_m & CAN_IFR_FAULT_OBJ_ID_M)
    {
        can_read_message(CAN_IFR_FAULT_OBJ_ID, rx_data);

        // Open SDC if SDC_Open flag is active
        if (rx_data[4] == INVERTER_SDC_COMMAND)
        {
            fault_set_wInverterSDCOpenRequest(0x0);  // doesn't clear
            sdc_control_open();  // critical so open immediately
        }
    }

    if (pending_msg_obj_m & CAN_IFL_FAULT_OBJ_ID_M)
    {
        can_read_message(CAN_IFL_FAULT_OBJ_ID, rx_data);

        // Open SDC if SDC_Open flag is active
        if (rx_data[4] == INVERTER_SDC_COMMAND)
        {
            fault_set_wInverterSDCOpenRequest(0x1);  // doesn't clear
            sdc_control_open();  // critical so open immediately
        }
    }

    if (pending_msg_obj_m & CAN_IRL_FAULT_OBJ_ID_M)
    {
        can_read_message(CAN_IRL_FAULT_OBJ_ID, rx_data);

        // Open SDC if SDC_Open flag is active
        if (rx_data[4] == INVERTER_SDC_COMMAND)
        {
            fault_set_wInverterSDCOpenRequest(0x2);  // doesn't clear
            sdc_control_open();  // critical so open immediately
        }
    }

    if (pending_msg_obj_m & CAN_IRR_FAULT_OBJ_ID_M)
    {
        can_read_message(CAN_IRR_FAULT_OBJ_ID, rx_data);

        // Open SDC if SDC_Open flag is active
        if (rx_data[4] == INVERTER_SDC_COMMAND)
        {
            fault_set_wInverterSDCOpenRequest(0x3);  // doesn't clear
            sdc_control_open();  // critical so open immediately
        }
    }

    // Bootloader
    if (pending_msg_obj_m & CAN_BOOTLOADER_PING_OBJ_ID_M)
    {
        can_read_message(CAN_BOOTLOADER_PING_OBJ_ID, rx_data);
        // Call the bootloader
        call_bootloader();
        // Should never return, but hang if error
        while(1) {}
    }

    // Aux Flags
    if (pending_msg_obj_m & CAN_AUX_FLAGS_OBJ_ID_M)
    {
        can_read_message(CAN_AUX_FLAGS_OBJ_ID, rx_data);
        can_parse_aux_flags(rx_data);
        aux_flags_timeout = 0;
    }

    can_check_timeouts(); // Check if any messages timed out
}


/**
 * @brief Send Cell Voltage Stats Message
 */
void can_send_stats_cell_voltage(void)
{
    uint8_t data[CAN_STATS_CELL_VOLTAGE_LEN];
    uint16_t temp;

    temp = bms.closed_cell_voltage_stats.average;
    data[0] = (uint8_t)temp;
    data[1] = (uint8_t)(temp >> 8);
    temp = bms.closed_cell_voltage_stats.max;
    data[2] = (uint8_t)temp;
    data[3] = (uint8_t)(temp >> 8);
    temp = bms.closed_cell_voltage_stats.max_id;
    data[4] = (uint8_t)temp;
    temp = bms.closed_cell_voltage_stats.min;
    data[5] = (uint8_t)temp;
    data[6] = (uint8_t)(temp >> 8);
    temp = bms.closed_cell_voltage_stats.min_id;
    data[7] = (uint8_t)temp;

    can_send_message(CAN_STATS_CELL_VOLTAGE_OBJ_ID, data);
}

/**
 * @brief Send Cell Temperature Message
 */
void can_send_stats_cell_temperature(void)
{
    uint8_t data[CAN_STATS_CELL_TEMPERATURE_LEN];
    uint16_t temp;

    temp = bms.cell_temperature_stats.average;
    data[0] = (uint8_t)temp;
    temp = bms.cell_temperature_stats.max;
    data[1] = (uint8_t)temp;
    temp = bms.cell_temperature_stats.max_id;
    data[2] = (uint8_t)temp;
    temp = bms.cell_temperature_stats.min;
    data[3] = (uint8_t)temp;
    temp = bms.cell_temperature_stats.min_id;
    data[4] = (uint8_t)temp;

    can_send_message(CAN_STATS_CELL_TEMPERATURE_OBJ_ID, data);
}

/**
 * @brief Send open cell voltage stats message
 */
void can_send_stats_ocv(void)
{
    uint8_t data[CAN_STATS_OCV_LEN];
    uint16_t temp;

    temp = bms.open_cell_voltage_stats.average;
    data[0] = (uint8_t)temp;
    data[1] = (uint8_t)(temp >> 8);
    temp = bms.open_cell_voltage_stats.max;
    data[2] = (uint8_t)temp;
    data[3] = (uint8_t)(temp >> 8);
    temp = bms.open_cell_voltage_stats.max_id;
    data[4] = (uint8_t)temp;
    temp = bms.open_cell_voltage_stats.min;
    data[5] = (uint8_t)temp;
    data[6] = (uint8_t)(temp >> 8);
    temp = bms.open_cell_voltage_stats.min_id;
    data[7] = (uint8_t)temp;

    can_send_message(CAN_STATS_OCV_OBJ_ID, data);
}

/**
 * Send cell discharge resistance stats CAN message.
 */
void can_send_stats_cell_dch_res(void)
{
    uint8_t data[CAN_STATS_CELL_DCH_RES_LEN];
    uint16_t temp;

    temp = bms.charge_res_stats.average;
    data[0] = (uint8_t)temp;
    data[1] = (uint8_t)(temp >> 8);
    temp = bms.charge_res_stats.max;
    data[2] = (uint8_t)temp;
    data[3] = (uint8_t)(temp >> 8);
    temp = bms.charge_res_stats.max_id;
    data[4] = (uint8_t)temp;
    temp = bms.charge_res_stats.min;
    data[5] = (uint8_t)temp;
    data[6] = (uint8_t)(temp >> 8);
    temp = bms.charge_res_stats.min_id;
    data[7] = (uint8_t)temp;

    can_send_message(CAN_STATS_CELL_DCH_RES_OBJ_ID, data);
}

/**
 * Send cell charge resistance stats CAN message.
 */
void can_send_stats_cell_ch_res(void)
{
    uint8_t data[CAN_STATS_CELL_CH_RES_LEN];
    uint16_t temp;

    temp = bms.discharge_res_stats.average;
    data[0] = (uint8_t)temp;
    data[1] = (uint8_t)(temp >> 8);
    temp = bms.discharge_res_stats.max;
    data[2] = (uint8_t)temp;
    data[3] = (uint8_t)(temp >> 8);
    temp = bms.discharge_res_stats.max_id;
    data[4] = (uint8_t)temp;
    temp = bms.discharge_res_stats.min;
    data[5] = (uint8_t)temp;
    data[6] = (uint8_t)(temp >> 8);
    temp = bms.discharge_res_stats.min_id;
    data[7] = (uint8_t)temp;

    can_send_message(CAN_STATS_CELL_CH_RES_OBJ_ID, data);
}

/**
 * Send BMS version.
 */
void can_send_bms_version(void)
{
    uint8_t data[8];

    const uint8_t major = 2; // max: 15
    const uint8_t minor = 0; // max: 15
    const uint8_t maintenance = 0; // max 256

    data[0] = ((major << 4) & 0Xf0) | (minor & 0xf);
    data[1] = maintenance;
//    data[2] = BUILD_HOUR;
//    data[3] = BUILD_MINUTE;
//    data[4] = BUILD_MONTH_BCD;
//    data[5] = BUILD_DAY_BCD;
//    data[6] = BUILD_YEAR_PREFIX_BCD;
//    data[7] = BUILD_YEAR_SUFFIX_BCD;

    can_send_message(CAN_BMS_VERSION_OBJ_ID, data);
}


void can_send_cell_balancing(void)
{
    uint8_t data[8];

    data[0] = 0;
    data[0] |= (fault_is_fBalancingActive() ? 0x01 : 0x00);
    data[1] = bms.balancing_cell_id;
    data[2] = bms.num_cells_balancing;

    uint16_t balancing_voltage = bms.balancing_vltg_limit;
    data[3] = (uint8_t)(balancing_voltage & 0xFF);
    data[4] = (uint8_t)((balancing_voltage >> 16) & 0xFF);

    can_send_message(CAN_CELL_BALANCING_OBJ_ID, data);
}


void can_send_stats_soc(void)
{
    uint8_t data[8];

    data[0] = bms_get_cell_soc_average() * 200;
    data[1] = bms_get_cell_soc_max() * 200;
    data[2] = bms_get_cell_soc_max_id();
    data[3] = bms_get_cell_soc_min() * 200;
    data[4] = bms_get_cell_soc_min_id();
    data[5] = 0;
    data[6] = 0;
    data[7] = 0;

    can_send_message(CAN_STATS_SOC_OBJ_ID, data);
}


void can_send_stats_capacity(void)
{
    uint8_t data[8];

    uint16_t avg = bms_get_cell_capacity_average() / 60 / 60;
    data[0] = avg;
    data[1] = (avg >> 8);

    uint16_t max = bms_get_cell_capacity_max() / 60 / 60;
    data[2] = max;
    data[3] = (max >> 8);

    data[4] = bms_get_cell_capacity_max_id();

    uint16_t min = bms_get_cell_capacity_min() / 60 / 60;
    data[5] = min;
    data[6] = (min >> 8);

    data[7] = bms_get_cell_capacity_min_id();

    can_send_message(CAN_STATS_CAPACITY_OBJ_ID, data);
}


void can_decrement_count(void)
{
    if (num_fault_msgs_in_5ms > 0)
    {
        num_fault_msgs_in_5ms--;
    }
}


void can_send_fault_matrix(void)
{
    can_send_message(CAN_FAULTS_MATRIX_OBJ_ID, fault_matrix_bit_flags);
}


void can_send_cell_broadcast_1(void)
{
    static uint8_t cell_i = 0;
    uint8_t data[CAN_CELL_BROADCAST_1_LEN];

    data[0] = cell_i;
    data[1] = (uint8_t)bms_get_closed_cell_voltage(cell_i);
    data[2] = (uint8_t)(bms_get_closed_cell_voltage(cell_i) >> 8);
    data[3] = (uint8_t)bms_get_open_cell_voltage(cell_i);
    data[4] = (uint8_t)(bms_get_open_cell_voltage(cell_i) >> 8);

    data[5] = bms_get_cell_ch_i(cell_i);

    data[6] = (uint8_t) bms_get_cell_dch_i(cell_i);
    data[7] = (uint8_t) (bms_get_cell_dch_i(cell_i) >> 8);

    can_send_message(CAN_CELL_BROADCAST_1_OBJ_ID, data);

     cell_i = (cell_i + 1) % TOTAL_CELLS;
}


void can_send_cell_broadcast_2(void)
{
    static uint8_t cell_i = 0;
    uint8_t data[CAN_CELL_BROADCAST_2_LEN];

    data[0] = cell_i;
    data[1] = bms_get_cell_charge_res(cell_i);
    data[2] = bms_get_cell_discharge_res(cell_i);
//    data[3] = bms_get_cell_charge_tau(cell_i);
//    data[4] = bms_get_cell_discharge_tau(cell_i);
    data[5] = bms_get_cell_temperature(cell_i); //Do I need to cast?

    can_send_message(CAN_CELL_BROADCAST_2_OBJ_ID, data);

    cell_i = (cell_i + 1) % TOTAL_CELLS;
}


void can_send_cell_broadcast_3(void)
{
    static uint8_t cell_i = 0;
    uint8_t data[CAN_CELL_BROADCAST_3_LEN];

    data[0] = cell_i;
    data[1] = (uint8_t) (bms_get_cell_capacity(cell_i) / CAPACITY_GAIN_DIV); //!< [0.1] Ah
    data[2] = (uint8_t) (( bms_get_cell_capacity(cell_i) / CAPACITY_GAIN_DIV) >> 8);
    data[3] = (uint8_t) (bms_get_cell_energy(cell_i) / ENERGY_GAIN_DIV); //!< [0.1] Wh
    data[4] = (uint8_t) (( bms_get_cell_energy(cell_i) / ENERGY_GAIN_DIV) >> 8);
    data[5] = (uint8_t) (bms_get_cell_soc(cell_i) * SOC_GAIN); //!< [0.5] %
    data[6] = (uint8_t) (bms_get_cell_soe(cell_i) *  SOE_GAIN); //!< [0.5] %
    data[7] = bms_get_cell_balancing_active(cell_i);

    can_send_message(CAN_CELL_BROADCAST_3_OBJ_ID, data);

    cell_i = (cell_i + 1) % TOTAL_CELLS;
}
